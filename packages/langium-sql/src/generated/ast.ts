/******************************************************************************
 * This file was generated by langium-cli 1.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type ColumnNameSource = ColumnDefinition | ExpressionQuery;

export const ColumnNameSource = 'ColumnNameSource';

export function isColumnNameSource(item: unknown): item is ColumnNameSource {
    return reflection.isInstance(item, ColumnNameSource);
}

export type Expression = BetweenExpression | BinaryExpression | BooleanLiteral | CastExpression | ColumnNameExpression | FunctionCall | HexStringLiteral | NegatableExpression | NullLiteral | NumberLiteral | ParenthesisOrListExpression | StringLiteral | SubQueryExpression | TableRelatedColumnExpression | UnaryExpression;

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export type FrameBetween = FrameRange;

export const FrameBetween = 'FrameBetween';

export function isFrameBetween(item: unknown): item is FrameBetween {
    return reflection.isInstance(item, FrameBetween);
}

export type FrameExtent = FrameBetween | FrameRange;

export const FrameExtent = 'FrameExtent';

export function isFrameExtent(item: unknown): item is FrameExtent {
    return reflection.isInstance(item, FrameExtent);
}

export type FrameRange = Expression;

export const FrameRange = 'FrameRange';

export function isFrameRange(item: unknown): item is FrameRange {
    return reflection.isInstance(item, FrameRange);
}

export type FrameUnits = 'RANGE' | 'ROWS';

export type Identifier = string;

export type SelectElement = AllStar | AllTable | ExpressionQuery;

export const SelectElement = 'SelectElement';

export function isSelectElement(item: unknown): item is SelectElement {
    return reflection.isInstance(item, SelectElement);
}

export type SelectStatementRootExpression = SelectTableExpression;

export const SelectStatementRootExpression = 'SelectStatementRootExpression';

export function isSelectStatementRootExpression(item: unknown): item is SelectStatementRootExpression {
    return reflection.isInstance(item, SelectStatementRootExpression);
}

export type SelectTableExpression = BinaryTableExpression | ParenthesesSelectTableExpression | SimpleSelectTableExpression;

export const SelectTableExpression = 'SelectTableExpression';

export function isSelectTableExpression(item: unknown): item is SelectTableExpression {
    return reflection.isInstance(item, SelectTableExpression);
}

export type SourceItem = SubQuerySourceItem | TableSourceItem;

export const SourceItem = 'SourceItem';

export function isSourceItem(item: unknown): item is SourceItem {
    return reflection.isInstance(item, SourceItem);
}

export type Statement = FunctionDefinition | RootLevelSelectStatement | SchemaDefinition | TableDefinition;

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export type TableContentDefinition = ColumnDefinition | ConstraintDefinition | KeyDefinition | PrimaryKeyDefinition;

export const TableContentDefinition = 'TableContentDefinition';

export function isTableContentDefinition(item: unknown): item is TableContentDefinition {
    return reflection.isInstance(item, TableContentDefinition);
}

export type TableLike = CommonTableExpression | TableDefinition;

export const TableLike = 'TableLike';

export function isTableLike(item: unknown): item is TableLike {
    return reflection.isInstance(item, TableLike);
}

export type TableVariableSource = SubQuerySourceItem | TableSourceItem;

export const TableVariableSource = 'TableVariableSource';

export function isTableVariableSource(item: unknown): item is TableVariableSource {
    return reflection.isInstance(item, TableVariableSource);
}

export type Type = BooleanType | CharType | DateTimeType | EnumType | IntegerType | RealType;

export const Type = 'Type';

export function isType(item: unknown): item is Type {
    return reflection.isInstance(item, Type);
}

export interface AllStar extends AstNode {
    readonly $container: SelectElements | TableDefinition;
    readonly $type: 'AllStar';
}

export const AllStar = 'AllStar';

export function isAllStar(item: unknown): item is AllStar {
    return reflection.isInstance(item, AllStar);
}

export interface AllTable extends AstNode {
    readonly $container: SelectElements | TableDefinition;
    readonly $type: 'AllTable';
    variableName: Reference<TableVariableSource>
}

export const AllTable = 'AllTable';

export function isAllTable(item: unknown): item is AllTable {
    return reflection.isInstance(item, AllTable);
}

export interface BetweenExpression extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'BetweenExpression';
    left: Expression
    negated: boolean
    right: Expression
    subExpr: Expression
}

export const BetweenExpression = 'BetweenExpression';

export function isBetweenExpression(item: unknown): item is BetweenExpression {
    return reflection.isInstance(item, BetweenExpression);
}

export interface BinaryExpression extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'BinaryExpression';
    left: Expression
    operator: '%' | '*' | '+' | '-' | '/' | '<' | '<=' | '<>' | '=' | '>' | '>=' | 'AND' | 'OR' | '||'
    right: Expression
}

export const BinaryExpression = 'BinaryExpression';

export function isBinaryExpression(item: unknown): item is BinaryExpression {
    return reflection.isInstance(item, BinaryExpression);
}

export interface BinaryTableExpression extends AstNode {
    readonly $container: BinaryTableExpression | CommonTableExpression | ParenthesesSelectTableExpression | RootLevelSelectStatement | SubQueryExpression | SubQuerySourceItem;
    readonly $type: 'BinaryTableExpression';
    left: SelectTableExpression
    operator: SetOperator
    right: SelectTableExpression
}

export const BinaryTableExpression = 'BinaryTableExpression';

export function isBinaryTableExpression(item: unknown): item is BinaryTableExpression {
    return reflection.isInstance(item, BinaryTableExpression);
}

export interface BooleanLiteral extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'BooleanLiteral';
    value: 'FALSE' | 'TRUE'
}

export const BooleanLiteral = 'BooleanLiteral';

export function isBooleanLiteral(item: unknown): item is BooleanLiteral {
    return reflection.isInstance(item, BooleanLiteral);
}

export interface BooleanType extends AstNode {
    readonly $container: CastExpression | ColumnDefinition | FormalParameterDefinition | FunctionDefinition;
    readonly $type: 'BooleanType';
}

export const BooleanType = 'BooleanType';

export function isBooleanType(item: unknown): item is BooleanType {
    return reflection.isInstance(item, BooleanType);
}

export interface CastExpression extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'CastExpression';
    expr: Expression
    type: Type
}

export const CastExpression = 'CastExpression';

export function isCastExpression(item: unknown): item is CastExpression {
    return reflection.isInstance(item, CastExpression);
}

export interface CharType extends AstNode {
    readonly $container: CastExpression | ColumnDefinition | FormalParameterDefinition | FunctionDefinition;
    readonly $type: 'CharType';
    length?: IntegerLiteral
}

export const CharType = 'CharType';

export function isCharType(item: unknown): item is CharType {
    return reflection.isInstance(item, CharType);
}

export interface ColumnDefinition extends AstNode {
    readonly $container: SelectElements | TableDefinition;
    readonly $type: 'ColumnDefinition';
    dataType: Type
    name: Identifier
    negated: boolean
    null: boolean
}

export const ColumnDefinition = 'ColumnDefinition';

export function isColumnDefinition(item: unknown): item is ColumnDefinition {
    return reflection.isInstance(item, ColumnDefinition);
}

export interface ColumnNameExpression extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'ColumnNameExpression';
    columnName: Reference<ColumnNameSource>
}

export const ColumnNameExpression = 'ColumnNameExpression';

export function isColumnNameExpression(item: unknown): item is ColumnNameExpression {
    return reflection.isInstance(item, ColumnNameExpression);
}

export interface CommonTableExpression extends AstNode {
    readonly $container: SqlFile | WithClause;
    readonly $type: 'CommonTableExpression';
    columnNames: Array<CteColumnName>
    name: Identifier
    statement: SelectStatementRootExpression
}

export const CommonTableExpression = 'CommonTableExpression';

export function isCommonTableExpression(item: unknown): item is CommonTableExpression {
    return reflection.isInstance(item, CommonTableExpression);
}

export interface ConstraintDefinition extends AstNode {
    readonly $container: SelectElements | TableDefinition;
    readonly $type: 'ConstraintDefinition';
    cascadeDeletion: boolean
    from: Reference<ColumnDefinition>
    name: Identifier
    table: Reference<TableDefinition>
    to: Reference<ColumnDefinition>
}

export const ConstraintDefinition = 'ConstraintDefinition';

export function isConstraintDefinition(item: unknown): item is ConstraintDefinition {
    return reflection.isInstance(item, ConstraintDefinition);
}

export interface CteColumnName extends AstNode {
    readonly $container: CommonTableExpression;
    readonly $type: 'CteColumnName';
    name: Identifier
}

export const CteColumnName = 'CteColumnName';

export function isCteColumnName(item: unknown): item is CteColumnName {
    return reflection.isInstance(item, CteColumnName);
}

export interface DateTimeType extends AstNode {
    readonly $container: CastExpression | ColumnDefinition | FormalParameterDefinition | FunctionDefinition;
    readonly $type: 'DateTimeType';
}

export const DateTimeType = 'DateTimeType';

export function isDateTimeType(item: unknown): item is DateTimeType {
    return reflection.isInstance(item, DateTimeType);
}

export interface EnumType extends AstNode {
    readonly $container: CastExpression | ColumnDefinition | FormalParameterDefinition | FunctionDefinition;
    readonly $type: 'EnumType';
    members: Array<string>
}

export const EnumType = 'EnumType';

export function isEnumType(item: unknown): item is EnumType {
    return reflection.isInstance(item, EnumType);
}

export interface ExpressionQuery extends AstNode {
    readonly $container: SelectElements | TableDefinition;
    readonly $type: 'ExpressionQuery';
    expr: Expression
    name?: Identifier
}

export const ExpressionQuery = 'ExpressionQuery';

export function isExpressionQuery(item: unknown): item is ExpressionQuery {
    return reflection.isInstance(item, ExpressionQuery);
}

export interface FormalParameterDefinition extends AstNode {
    readonly $container: FunctionDefinition;
    readonly $type: 'FormalParameterDefinition';
    dataType: Type
    name: Identifier
}

export const FormalParameterDefinition = 'FormalParameterDefinition';

export function isFormalParameterDefinition(item: unknown): item is FormalParameterDefinition {
    return reflection.isInstance(item, FormalParameterDefinition);
}

export interface FromClause extends AstNode {
    readonly $container: SimpleSelectStatement;
    readonly $type: 'FromClause';
    sources: TableSources
}

export const FromClause = 'FromClause';

export function isFromClause(item: unknown): item is FromClause {
    return reflection.isInstance(item, FromClause);
}

export interface FunctionCall extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'FunctionCall';
    functionName: Reference<FunctionDefinition>
    overClause?: OverClause
    params?: SelectElements
    schemaName?: Reference<SchemaDefinition>
}

export const FunctionCall = 'FunctionCall';

export function isFunctionCall(item: unknown): item is FunctionCall {
    return reflection.isInstance(item, FunctionCall);
}

export interface FunctionDefinition extends AstNode {
    readonly $container: SqlFile | WithClause;
    readonly $type: 'FunctionDefinition';
    name: Identifier
    params: Array<FormalParameterDefinition>
    returnType: Type
    schemaName?: Reference<SchemaDefinition>
}

export const FunctionDefinition = 'FunctionDefinition';

export function isFunctionDefinition(item: unknown): item is FunctionDefinition {
    return reflection.isInstance(item, FunctionDefinition);
}

export interface GroupByClause extends AstNode {
    readonly $container: SimpleSelectStatement;
    readonly $type: 'GroupByClause';
    specs: Array<Expression>
}

export const GroupByClause = 'GroupByClause';

export function isGroupByClause(item: unknown): item is GroupByClause {
    return reflection.isInstance(item, GroupByClause);
}

export interface HavingClause extends AstNode {
    readonly $container: SimpleSelectStatement;
    readonly $type: 'HavingClause';
    groupCondition: Expression
}

export const HavingClause = 'HavingClause';

export function isHavingClause(item: unknown): item is HavingClause {
    return reflection.isInstance(item, HavingClause);
}

export interface HexStringLiteral extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'HexStringLiteral';
    value: string
}

export const HexStringLiteral = 'HexStringLiteral';

export function isHexStringLiteral(item: unknown): item is HexStringLiteral {
    return reflection.isInstance(item, HexStringLiteral);
}

export interface IntegerLiteral extends AstNode {
    readonly $container: CharType;
    readonly $type: 'IntegerLiteral';
    value: number
}

export const IntegerLiteral = 'IntegerLiteral';

export function isIntegerLiteral(item: unknown): item is IntegerLiteral {
    return reflection.isInstance(item, IntegerLiteral);
}

export interface IntegerType extends AstNode {
    readonly $container: CastExpression | ColumnDefinition | FormalParameterDefinition | FunctionDefinition;
    readonly $type: 'IntegerType';
}

export const IntegerType = 'IntegerType';

export function isIntegerType(item: unknown): item is IntegerType {
    return reflection.isInstance(item, IntegerType);
}

export interface JoinPart extends AstNode {
    readonly $container: TableSource;
    readonly $type: 'JoinPart';
    joinOn?: Expression
    leftJoin: boolean
    nextItem: SourceItem
    rightJoin: boolean
    usingOn?: Expression
}

export const JoinPart = 'JoinPart';

export function isJoinPart(item: unknown): item is JoinPart {
    return reflection.isInstance(item, JoinPart);
}

export interface KeyDefinition extends AstNode {
    readonly $container: SelectElements | TableDefinition;
    readonly $type: 'KeyDefinition';
    keys: Array<Reference<ColumnDefinition>>
    name: Identifier
    unique: boolean
}

export const KeyDefinition = 'KeyDefinition';

export function isKeyDefinition(item: unknown): item is KeyDefinition {
    return reflection.isInstance(item, KeyDefinition);
}

export interface NegatableExpression extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'NegatableExpression';
    left: Expression
    negated: boolean
    operator: 'IN' | 'IS' | 'LIKE'
    right: Expression
}

export const NegatableExpression = 'NegatableExpression';

export function isNegatableExpression(item: unknown): item is NegatableExpression {
    return reflection.isInstance(item, NegatableExpression);
}

export interface NullLiteral extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'NullLiteral';
}

export const NullLiteral = 'NullLiteral';

export function isNullLiteral(item: unknown): item is NullLiteral {
    return reflection.isInstance(item, NullLiteral);
}

export interface NumberLiteral extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'NumberLiteral';
    value: number
}

export const NumberLiteral = 'NumberLiteral';

export function isNumberLiteral(item: unknown): item is NumberLiteral {
    return reflection.isInstance(item, NumberLiteral);
}

export interface OrderBySpec extends AstNode {
    readonly $container: OrderByClause;
    readonly $type: 'OrderBySpec';
    scalar: Expression
}

export const OrderBySpec = 'OrderBySpec';

export function isOrderBySpec(item: unknown): item is OrderBySpec {
    return reflection.isInstance(item, OrderBySpec);
}

export interface OverClause extends AstNode {
    readonly $container: FunctionCall;
    readonly $type: 'OverClause';
    spec?: WindowSpec
    windowName?: Reference<WindowSpec>
}

export const OverClause = 'OverClause';

export function isOverClause(item: unknown): item is OverClause {
    return reflection.isInstance(item, OverClause);
}

export interface ParenthesesSelectTableExpression extends AstNode {
    readonly $container: BinaryTableExpression | CommonTableExpression | ParenthesesSelectTableExpression | RootLevelSelectStatement | SubQueryExpression | SubQuerySourceItem;
    readonly $type: 'ParenthesesSelectTableExpression';
    value: SelectStatementRootExpression
}

export const ParenthesesSelectTableExpression = 'ParenthesesSelectTableExpression';

export function isParenthesesSelectTableExpression(item: unknown): item is ParenthesesSelectTableExpression {
    return reflection.isInstance(item, ParenthesesSelectTableExpression);
}

export interface ParenthesisOrListExpression extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'ParenthesisOrListExpression';
    items: Array<Expression>
}

export const ParenthesisOrListExpression = 'ParenthesisOrListExpression';

export function isParenthesisOrListExpression(item: unknown): item is ParenthesisOrListExpression {
    return reflection.isInstance(item, ParenthesisOrListExpression);
}

export interface PrimaryKeyDefinition extends AstNode {
    readonly $container: SelectElements | TableDefinition;
    readonly $type: 'PrimaryKeyDefinition';
    primaryKeys: Array<Reference<ColumnDefinition>>
}

export const PrimaryKeyDefinition = 'PrimaryKeyDefinition';

export function isPrimaryKeyDefinition(item: unknown): item is PrimaryKeyDefinition {
    return reflection.isInstance(item, PrimaryKeyDefinition);
}

export interface RealType extends AstNode {
    readonly $container: CastExpression | ColumnDefinition | FormalParameterDefinition | FunctionDefinition;
    readonly $type: 'RealType';
}

export const RealType = 'RealType';

export function isRealType(item: unknown): item is RealType {
    return reflection.isInstance(item, RealType);
}

export interface RootLevelSelectStatement extends AstNode {
    readonly $container: SqlFile | WithClause;
    readonly $type: 'RootLevelSelectStatement';
    select: SelectStatementRootExpression
    with?: WithClause
}

export const RootLevelSelectStatement = 'RootLevelSelectStatement';

export function isRootLevelSelectStatement(item: unknown): item is RootLevelSelectStatement {
    return reflection.isInstance(item, RootLevelSelectStatement);
}

export interface SchemaDefinition extends AstNode {
    readonly $container: SqlFile | WithClause;
    readonly $type: 'SchemaDefinition';
    name: Identifier
}

export const SchemaDefinition = 'SchemaDefinition';

export function isSchemaDefinition(item: unknown): item is SchemaDefinition {
    return reflection.isInstance(item, SchemaDefinition);
}

export interface SelectElements extends AstNode {
    readonly $container: FunctionCall | SimpleSelectStatement;
    readonly $type: 'SelectElements';
    distinct: boolean
    elements: Array<SelectElement>
}

export const SelectElements = 'SelectElements';

export function isSelectElements(item: unknown): item is SelectElements {
    return reflection.isInstance(item, SelectElements);
}

export interface SetOperator extends AstNode {
    readonly $container: BinaryTableExpression;
    readonly $type: 'SetOperator';
    distinct: boolean
    operator: 'EXCEPT' | 'INTERSECT' | 'MINUS' | 'UNION'
}

export const SetOperator = 'SetOperator';

export function isSetOperator(item: unknown): item is SetOperator {
    return reflection.isInstance(item, SetOperator);
}

export interface SimpleSelectStatement extends AstNode {
    readonly $container: SimpleSelectTableExpression;
    readonly $type: 'SimpleSelectStatement';
    from?: FromClause
    groupBy?: GroupByClause
    having?: HavingClause
    orderBy?: OrderByClause
    select: SelectElements
    where?: WhereClause
}

export const SimpleSelectStatement = 'SimpleSelectStatement';

export function isSimpleSelectStatement(item: unknown): item is SimpleSelectStatement {
    return reflection.isInstance(item, SimpleSelectStatement);
}

export interface SimpleSelectTableExpression extends AstNode {
    readonly $container: BinaryTableExpression | CommonTableExpression | ParenthesesSelectTableExpression | RootLevelSelectStatement | SubQueryExpression | SubQuerySourceItem;
    readonly $type: 'SimpleSelectTableExpression';
    select: SimpleSelectStatement
}

export const SimpleSelectTableExpression = 'SimpleSelectTableExpression';

export function isSimpleSelectTableExpression(item: unknown): item is SimpleSelectTableExpression {
    return reflection.isInstance(item, SimpleSelectTableExpression);
}

export interface SqlFile extends AstNode {
    readonly $type: 'SqlFile';
    statements: Array<Statement>
}

export const SqlFile = 'SqlFile';

export function isSqlFile(item: unknown): item is SqlFile {
    return reflection.isInstance(item, SqlFile);
}

export interface StringLiteral extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'StringLiteral';
    value: string
}

export const StringLiteral = 'StringLiteral';

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, StringLiteral);
}

export interface SubQueryExpression extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'SubQueryExpression';
    subQuery: SelectStatementRootExpression
}

export const SubQueryExpression = 'SubQueryExpression';

export function isSubQueryExpression(item: unknown): item is SubQueryExpression {
    return reflection.isInstance(item, SubQueryExpression);
}

export interface SubQuerySourceItem extends AstNode {
    readonly $container: JoinPart | TableSource;
    readonly $type: 'SubQuerySourceItem';
    name?: Identifier
    subQuery: SelectStatementRootExpression
}

export const SubQuerySourceItem = 'SubQuerySourceItem';

export function isSubQuerySourceItem(item: unknown): item is SubQuerySourceItem {
    return reflection.isInstance(item, SubQuerySourceItem);
}

export interface TableDefinition extends AstNode {
    readonly $container: SqlFile | WithClause;
    readonly $type: 'TableDefinition';
    columns: Array<TableContentDefinition>
    name: Identifier
    schemaName?: Reference<SchemaDefinition>
    trailingComma: boolean
}

export const TableDefinition = 'TableDefinition';

export function isTableDefinition(item: unknown): item is TableDefinition {
    return reflection.isInstance(item, TableDefinition);
}

export interface TableRelatedColumnExpression extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'TableRelatedColumnExpression';
    columnName: Reference<ColumnNameSource>
    variableName: Reference<SourceItem>
}

export const TableRelatedColumnExpression = 'TableRelatedColumnExpression';

export function isTableRelatedColumnExpression(item: unknown): item is TableRelatedColumnExpression {
    return reflection.isInstance(item, TableRelatedColumnExpression);
}

export interface TableSource extends AstNode {
    readonly $container: TableSources;
    readonly $type: 'TableSource';
    item: SourceItem
    joins: Array<JoinPart>
}

export const TableSource = 'TableSource';

export function isTableSource(item: unknown): item is TableSource {
    return reflection.isInstance(item, TableSource);
}

export interface TableSourceItem extends AstNode {
    readonly $container: JoinPart | TableSource;
    readonly $type: 'TableSourceItem';
    name?: Identifier
    schemaName?: Reference<SchemaDefinition>
    tableName: Reference<TableLike>
}

export const TableSourceItem = 'TableSourceItem';

export function isTableSourceItem(item: unknown): item is TableSourceItem {
    return reflection.isInstance(item, TableSourceItem);
}

export interface TableSources extends AstNode {
    readonly $container: FromClause;
    readonly $type: 'TableSources';
    list: Array<TableSource>
}

export const TableSources = 'TableSources';

export function isTableSources(item: unknown): item is TableSources {
    return reflection.isInstance(item, TableSources);
}

export interface UnaryExpression extends AstNode {
    readonly $container: BetweenExpression | BinaryExpression | CastExpression | ExpressionQuery | FrameClause | GroupByClause | HavingClause | JoinPart | NegatableExpression | OrderBySpec | ParenthesisOrListExpression | PartitionClause | UnaryExpression | WhereClause;
    readonly $type: 'UnaryExpression';
    operator: '+' | '-' | 'NOT'
    value: Expression
}

export const UnaryExpression = 'UnaryExpression';

export function isUnaryExpression(item: unknown): item is UnaryExpression {
    return reflection.isInstance(item, UnaryExpression);
}

export interface WhereClause extends AstNode {
    readonly $container: SimpleSelectStatement;
    readonly $type: 'WhereClause';
    rowCondition: Expression
}

export const WhereClause = 'WhereClause';

export function isWhereClause(item: unknown): item is WhereClause {
    return reflection.isInstance(item, WhereClause);
}

export interface WindowSpec extends AstNode {
    readonly $container: OverClause | SimpleSelectStatement;
    readonly $type: 'FrameClause' | 'OrderByClause' | 'PartitionClause' | 'WindowSpec';
    name?: Identifier
}

export const WindowSpec = 'WindowSpec';

export function isWindowSpec(item: unknown): item is WindowSpec {
    return reflection.isInstance(item, WindowSpec);
}

export interface WithClause extends AstNode {
    readonly $container: RootLevelSelectStatement;
    readonly $type: 'WithClause';
    ctes: Array<CommonTableExpression>
}

export const WithClause = 'WithClause';

export function isWithClause(item: unknown): item is WithClause {
    return reflection.isInstance(item, WithClause);
}

export interface FrameClause extends WindowSpec {
    readonly $container: OverClause | SimpleSelectStatement;
    readonly $type: 'FrameClause';
    extent: FrameExtent
    units: FrameUnits
}

export const FrameClause = 'FrameClause';

export function isFrameClause(item: unknown): item is FrameClause {
    return reflection.isInstance(item, FrameClause);
}

export interface OrderByClause extends WindowSpec {
    readonly $container: OverClause | SimpleSelectStatement;
    readonly $type: 'OrderByClause';
    specs: Array<OrderBySpec>
}

export const OrderByClause = 'OrderByClause';

export function isOrderByClause(item: unknown): item is OrderByClause {
    return reflection.isInstance(item, OrderByClause);
}

export interface PartitionClause extends WindowSpec {
    readonly $container: OverClause | SimpleSelectStatement;
    readonly $type: 'PartitionClause';
    exprs: Array<Expression>
}

export const PartitionClause = 'PartitionClause';

export function isPartitionClause(item: unknown): item is PartitionClause {
    return reflection.isInstance(item, PartitionClause);
}

export interface SqlAstType {
    AllStar: AllStar
    AllTable: AllTable
    BetweenExpression: BetweenExpression
    BinaryExpression: BinaryExpression
    BinaryTableExpression: BinaryTableExpression
    BooleanLiteral: BooleanLiteral
    BooleanType: BooleanType
    CastExpression: CastExpression
    CharType: CharType
    ColumnDefinition: ColumnDefinition
    ColumnNameExpression: ColumnNameExpression
    ColumnNameSource: ColumnNameSource
    CommonTableExpression: CommonTableExpression
    ConstraintDefinition: ConstraintDefinition
    CteColumnName: CteColumnName
    DateTimeType: DateTimeType
    EnumType: EnumType
    Expression: Expression
    ExpressionQuery: ExpressionQuery
    FormalParameterDefinition: FormalParameterDefinition
    FrameBetween: FrameBetween
    FrameClause: FrameClause
    FrameExtent: FrameExtent
    FrameRange: FrameRange
    FromClause: FromClause
    FunctionCall: FunctionCall
    FunctionDefinition: FunctionDefinition
    GroupByClause: GroupByClause
    HavingClause: HavingClause
    HexStringLiteral: HexStringLiteral
    IntegerLiteral: IntegerLiteral
    IntegerType: IntegerType
    JoinPart: JoinPart
    KeyDefinition: KeyDefinition
    NegatableExpression: NegatableExpression
    NullLiteral: NullLiteral
    NumberLiteral: NumberLiteral
    OrderByClause: OrderByClause
    OrderBySpec: OrderBySpec
    OverClause: OverClause
    ParenthesesSelectTableExpression: ParenthesesSelectTableExpression
    ParenthesisOrListExpression: ParenthesisOrListExpression
    PartitionClause: PartitionClause
    PrimaryKeyDefinition: PrimaryKeyDefinition
    RealType: RealType
    RootLevelSelectStatement: RootLevelSelectStatement
    SchemaDefinition: SchemaDefinition
    SelectElement: SelectElement
    SelectElements: SelectElements
    SelectStatementRootExpression: SelectStatementRootExpression
    SelectTableExpression: SelectTableExpression
    SetOperator: SetOperator
    SimpleSelectStatement: SimpleSelectStatement
    SimpleSelectTableExpression: SimpleSelectTableExpression
    SourceItem: SourceItem
    SqlFile: SqlFile
    Statement: Statement
    StringLiteral: StringLiteral
    SubQueryExpression: SubQueryExpression
    SubQuerySourceItem: SubQuerySourceItem
    TableContentDefinition: TableContentDefinition
    TableDefinition: TableDefinition
    TableLike: TableLike
    TableRelatedColumnExpression: TableRelatedColumnExpression
    TableSource: TableSource
    TableSourceItem: TableSourceItem
    TableSources: TableSources
    TableVariableSource: TableVariableSource
    Type: Type
    UnaryExpression: UnaryExpression
    WhereClause: WhereClause
    WindowSpec: WindowSpec
    WithClause: WithClause
}

export class SqlAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['AllStar', 'AllTable', 'BetweenExpression', 'BinaryExpression', 'BinaryTableExpression', 'BooleanLiteral', 'BooleanType', 'CastExpression', 'CharType', 'ColumnDefinition', 'ColumnNameExpression', 'ColumnNameSource', 'CommonTableExpression', 'ConstraintDefinition', 'CteColumnName', 'DateTimeType', 'EnumType', 'Expression', 'ExpressionQuery', 'FormalParameterDefinition', 'FrameBetween', 'FrameClause', 'FrameExtent', 'FrameRange', 'FromClause', 'FunctionCall', 'FunctionDefinition', 'GroupByClause', 'HavingClause', 'HexStringLiteral', 'IntegerLiteral', 'IntegerType', 'JoinPart', 'KeyDefinition', 'NegatableExpression', 'NullLiteral', 'NumberLiteral', 'OrderByClause', 'OrderBySpec', 'OverClause', 'ParenthesesSelectTableExpression', 'ParenthesisOrListExpression', 'PartitionClause', 'PrimaryKeyDefinition', 'RealType', 'RootLevelSelectStatement', 'SchemaDefinition', 'SelectElement', 'SelectElements', 'SelectStatementRootExpression', 'SelectTableExpression', 'SetOperator', 'SimpleSelectStatement', 'SimpleSelectTableExpression', 'SourceItem', 'SqlFile', 'Statement', 'StringLiteral', 'SubQueryExpression', 'SubQuerySourceItem', 'TableContentDefinition', 'TableDefinition', 'TableLike', 'TableRelatedColumnExpression', 'TableSource', 'TableSourceItem', 'TableSources', 'TableVariableSource', 'Type', 'UnaryExpression', 'WhereClause', 'WindowSpec', 'WithClause'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case AllStar:
            case AllTable: {
                return this.isSubtype(SelectElement, supertype);
            }
            case BetweenExpression:
            case BinaryExpression:
            case BooleanLiteral:
            case CastExpression:
            case ColumnNameExpression:
            case FunctionCall:
            case HexStringLiteral:
            case NegatableExpression:
            case NullLiteral:
            case NumberLiteral:
            case ParenthesisOrListExpression:
            case StringLiteral:
            case SubQueryExpression:
            case TableRelatedColumnExpression:
            case UnaryExpression: {
                return this.isSubtype(Expression, supertype);
            }
            case BinaryTableExpression:
            case ParenthesesSelectTableExpression:
            case SimpleSelectTableExpression: {
                return this.isSubtype(SelectTableExpression, supertype);
            }
            case BooleanType:
            case CharType:
            case DateTimeType:
            case EnumType:
            case IntegerType:
            case RealType: {
                return this.isSubtype(Type, supertype);
            }
            case ColumnDefinition: {
                return this.isSubtype(ColumnNameSource, supertype) || this.isSubtype(TableContentDefinition, supertype);
            }
            case CommonTableExpression: {
                return this.isSubtype(TableLike, supertype);
            }
            case ConstraintDefinition:
            case KeyDefinition:
            case PrimaryKeyDefinition: {
                return this.isSubtype(TableContentDefinition, supertype);
            }
            case Expression: {
                return this.isSubtype(FrameRange, supertype);
            }
            case ExpressionQuery: {
                return this.isSubtype(ColumnNameSource, supertype) || this.isSubtype(SelectElement, supertype);
            }
            case FrameBetween: {
                return this.isSubtype(FrameExtent, supertype);
            }
            case FrameClause:
            case OrderByClause:
            case PartitionClause: {
                return this.isSubtype(WindowSpec, supertype);
            }
            case FrameRange: {
                return this.isSubtype(FrameBetween, supertype) || this.isSubtype(FrameExtent, supertype);
            }
            case FunctionDefinition:
            case RootLevelSelectStatement:
            case SchemaDefinition: {
                return this.isSubtype(Statement, supertype);
            }
            case SelectTableExpression: {
                return this.isSubtype(SelectStatementRootExpression, supertype);
            }
            case SubQuerySourceItem:
            case TableSourceItem: {
                return this.isSubtype(SourceItem, supertype) || this.isSubtype(TableVariableSource, supertype);
            }
            case TableDefinition: {
                return this.isSubtype(Statement, supertype) || this.isSubtype(TableLike, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'AllTable:variableName': {
                return TableVariableSource;
            }
            case 'ColumnNameExpression:columnName':
            case 'TableRelatedColumnExpression:columnName': {
                return ColumnNameSource;
            }
            case 'ConstraintDefinition:from':
            case 'ConstraintDefinition:to':
            case 'KeyDefinition:keys':
            case 'PrimaryKeyDefinition:primaryKeys': {
                return ColumnDefinition;
            }
            case 'ConstraintDefinition:table': {
                return TableDefinition;
            }
            case 'FunctionCall:functionName': {
                return FunctionDefinition;
            }
            case 'FunctionCall:schemaName':
            case 'FunctionDefinition:schemaName':
            case 'TableDefinition:schemaName':
            case 'TableSourceItem:schemaName': {
                return SchemaDefinition;
            }
            case 'OverClause:windowName': {
                return WindowSpec;
            }
            case 'TableRelatedColumnExpression:variableName': {
                return SourceItem;
            }
            case 'TableSourceItem:tableName': {
                return TableLike;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'BetweenExpression': {
                return {
                    name: 'BetweenExpression',
                    mandatory: [
                        { name: 'negated', type: 'boolean' }
                    ]
                };
            }
            case 'ColumnDefinition': {
                return {
                    name: 'ColumnDefinition',
                    mandatory: [
                        { name: 'negated', type: 'boolean' },
                        { name: 'null', type: 'boolean' }
                    ]
                };
            }
            case 'CommonTableExpression': {
                return {
                    name: 'CommonTableExpression',
                    mandatory: [
                        { name: 'columnNames', type: 'array' }
                    ]
                };
            }
            case 'ConstraintDefinition': {
                return {
                    name: 'ConstraintDefinition',
                    mandatory: [
                        { name: 'cascadeDeletion', type: 'boolean' }
                    ]
                };
            }
            case 'EnumType': {
                return {
                    name: 'EnumType',
                    mandatory: [
                        { name: 'members', type: 'array' }
                    ]
                };
            }
            case 'FunctionDefinition': {
                return {
                    name: 'FunctionDefinition',
                    mandatory: [
                        { name: 'params', type: 'array' }
                    ]
                };
            }
            case 'GroupByClause': {
                return {
                    name: 'GroupByClause',
                    mandatory: [
                        { name: 'specs', type: 'array' }
                    ]
                };
            }
            case 'JoinPart': {
                return {
                    name: 'JoinPart',
                    mandatory: [
                        { name: 'leftJoin', type: 'boolean' },
                        { name: 'rightJoin', type: 'boolean' }
                    ]
                };
            }
            case 'KeyDefinition': {
                return {
                    name: 'KeyDefinition',
                    mandatory: [
                        { name: 'keys', type: 'array' },
                        { name: 'unique', type: 'boolean' }
                    ]
                };
            }
            case 'NegatableExpression': {
                return {
                    name: 'NegatableExpression',
                    mandatory: [
                        { name: 'negated', type: 'boolean' }
                    ]
                };
            }
            case 'ParenthesisOrListExpression': {
                return {
                    name: 'ParenthesisOrListExpression',
                    mandatory: [
                        { name: 'items', type: 'array' }
                    ]
                };
            }
            case 'PrimaryKeyDefinition': {
                return {
                    name: 'PrimaryKeyDefinition',
                    mandatory: [
                        { name: 'primaryKeys', type: 'array' }
                    ]
                };
            }
            case 'SelectElements': {
                return {
                    name: 'SelectElements',
                    mandatory: [
                        { name: 'distinct', type: 'boolean' },
                        { name: 'elements', type: 'array' }
                    ]
                };
            }
            case 'SetOperator': {
                return {
                    name: 'SetOperator',
                    mandatory: [
                        { name: 'distinct', type: 'boolean' }
                    ]
                };
            }
            case 'SqlFile': {
                return {
                    name: 'SqlFile',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            case 'TableDefinition': {
                return {
                    name: 'TableDefinition',
                    mandatory: [
                        { name: 'columns', type: 'array' },
                        { name: 'trailingComma', type: 'boolean' }
                    ]
                };
            }
            case 'TableSource': {
                return {
                    name: 'TableSource',
                    mandatory: [
                        { name: 'joins', type: 'array' }
                    ]
                };
            }
            case 'TableSources': {
                return {
                    name: 'TableSources',
                    mandatory: [
                        { name: 'list', type: 'array' }
                    ]
                };
            }
            case 'WithClause': {
                return {
                    name: 'WithClause',
                    mandatory: [
                        { name: 'ctes', type: 'array' }
                    ]
                };
            }
            case 'OrderByClause': {
                return {
                    name: 'OrderByClause',
                    mandatory: [
                        { name: 'specs', type: 'array' }
                    ]
                };
            }
            case 'PartitionClause': {
                return {
                    name: 'PartitionClause',
                    mandatory: [
                        { name: 'exprs', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new SqlAstReflection();
